// Copyright 2017-2019 Jason Tackaberry
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

desc:Reaticulate

// Attach to the global shared buffer for communication to the main Lua script.
// This requires Reaper 5.97 or later.  See GMEM_IDX_* constants below.
options:gmem=reaticulate

// byte 0: serial to indicate gmem appdata has changed.  Wraps as needed.
// byte 1: reabank version (mod 256)
// byte 2: version
// byte 3: magic
//
// Defaults to RFX_MAGIC + RFX_VERSION consts (defined below)
slider1:704708608<0,2147483647,1>Reaticulate metadata

// The index within the gmem buffer for the start of this instance's data
slider2:0<0,2147483647,1>gmem index

// Bitmap of MIDI channels with active (held) notes.  Used by the
// GUI to indicate activity on channels.
slider3:0<0,2147483647,1>-Active Notes

slider4:0<0,2147483647,1>instance id
slider5:0<0,2147483647,1>-Unused
slider6:0<0,2147483647,1>-Unused
slider7:0<0,2147483647,1>-Unused
slider8:0<0,2147483647,1>-Unused

// For debugging
slider9:0<0,16,1>Show debug info for channel

// This group of sliders communicates information about each MIDI channel
// back to the GUI.  Each slider value is defined as:
//     byte 0: current program number for group 1; 128 == disabled
//     byte 1: current program number for group 2; 128 == disabled
//     byte 2: current program number for group 3; 128 == disabled
//     byte 3: current program number for group 4; see slider26 for disabled
slider10:8421504<0,2147483647,1>Reaticulate data for channel 1
slider11:8421504<0,2147483647,1>Reaticulate data for channel 2
slider12:8421504<0,2147483647,1>-Reaticulate data for channel 3
slider13:8421504<0,2147483647,1>-Reaticulate data for channel 4
slider14:8421504<0,2147483647,1>-Reaticulate data for channel 5
slider15:8421504<0,2147483647,1>-Reaticulate data for channel 6
slider16:8421504<0,2147483647,1>-Reaticulate data for channel 7
slider17:8421504<0,2147483647,1>-Reaticulate data for channel 8
slider18:8421504<0,2147483647,1>-Reaticulate data for channel 9
slider19:8421504<0,2147483647,1>-Reaticulate data for channel 10
slider20:8421504<0,2147483647,1>-Reaticulate data for channel 11
slider21:8421504<0,2147483647,1>-Reaticulate data for channel 12
slider22:8421504<0,2147483647,1>-Reaticulate data for channel 13
slider23:8421504<0,2147483647,1>-Reaticulate data for channel 14
slider24:8421504<0,2147483647,1>-Reaticulate data for channel 15
slider25:8421504<0,2147483647,1>-Reaticulate data for channel 16

// Kludge alert: MSB only has 7 usable bits, so group 4 values above can't hold
// a value of 128.  This slider holds a bitmap where bits 0-15 represent
// program enabled for MIDI channels 1-16 in group 4.
slider26:0<0,2147483647,1>-Group 4 program enabled state

slider27:0<0,2147483647,1>-Unused
slider28:0<0,2147483647,1>-Unused
slider29:0<0,2147483647,1>-Unused

// This group of sliders is used just to provide track-specific data storage
// for the GUI.  The actual encoding of these values is defined
// within that script and this JSFX is agnostic.  This is used, for example,
// to store the current banks assigned to this track.
slider30:0<0,2147483647,1>-Reaticulate Track Data 0
slider31:0<0,2147483647,1>-Reaticulate Track Data 1
slider32:0<0,2147483647,1>-Reaticulate Track Data 2
slider33:0<0,2147483647,1>-Reaticulate Track Data 3
slider34:0<0,2147483647,1>-Reaticulate Track Data 4
slider35:0<0,2147483647,1>-Reaticulate Track Data 5
slider36:0<0,2147483647,1>-Reaticulate Track Data 6
slider37:0<0,2147483647,1>-Reaticulate Track Data 7
slider38:0<0,2147483647,1>-Reaticulate Track Data 8
slider39:0<0,2147483647,1>-Reaticulate Track Data 9
slider40:0<0,2147483647,1>-Reaticulate Track Data 10
slider41:0<0,2147483647,1>-Reaticulate Track Data 11
slider42:0<0,2147483647,1>-Reaticulate Track Data 12
slider43:0<0,2147483647,1>-Reaticulate Track Data 13
slider44:0<0,2147483647,1>-Reaticulate Track Data 14
slider45:0<0,2147483647,1>-Reaticulate Track Data 15
slider46:0<0,2147483647,1>-Reaticulate Track Data 16
slider47:0<0,2147483647,1>-Reaticulate Track Data 17
slider48:0<0,2147483647,1>-Reaticulate Track Data 18
slider49:0<0,2147483647,1>-Reaticulate Track Data 19
slider50:0<0,2147483647,1>-Reaticulate Track Data 20
slider51:0<0,2147483647,1>-Reaticulate Track Data 21
slider52:0<0,2147483647,1>-Reaticulate Track Data 22
slider53:0<0,2147483647,1>-Reaticulate Track Data 23
slider54:0<0,2147483647,1>-Reaticulate Track Data 24
slider55:0<0,2147483647,1>-Reaticulate Track Data 25
slider56:0<0,2147483647,1>-Reaticulate Track Data 26
slider57:0<0,2147483647,1>-Reaticulate Track Data 27
slider58:0<0,2147483647,1>-Reaticulate Track Data 28
slider59:0<0,2147483647,1>-Reaticulate Track Data 29

slider60:0<0,2147483647,1>-Unused
slider61:0<0,2147483647,1>-Unused
slider62:0<0,2147483647,1>History Serial

slider63:0<0,2147483647,1>-Unused


// Special assembler-esque interface used by the GUI for programming the RFX.
// See OPCODE_* constants below.
slider64:42<0,2147483647,1>opcode

in_pin:none
out_pin:none





@init
ext_noinit = 1;
ext_midi_bus = 1;

// Misc constants
RFX_MAGIC = (42 << 24);
RFX_VERSION = (1 << 16);

MIDI_EVENT_PROGRAM = 0xc0;
MIDI_EVENT_CC = 0xb0;
MIDI_EVENT_NOTE_ON = 0x90;
MIDI_EVENT_NOTE_OFF = 0x80;
SLIDER_OFFSET_CONTROL = 10;
SLIDER_OPCODE = 64;
MAX_GROUPS = 4;
MAX_HELD_KEYSWITCHES = 8;
MAX_BANKS = 16;
MAX_CHANNELS = 16;
MAX_UNDO_SLOTS = 100;

// The GMEM_IDX_* constants refer to the index number within the gmem shared
// buffer. These are initialized by the main script.
//
// If this index is set to GMEM_MAGIC then we know the main script as
// initialized the global parameters (rfx offset, stride, etc)
GMEM_GIDX_MAGIC = 0;
GMEM_MAGIC = 0xbadc0de;

// Version number of gmem communication protocol with main script.  If this
// value changes on us, we must reinitialize our instance gmem based on the
// global parameters.
GMEM_GIDX_VERSION = 1;
// A monotonically increasing serial as set by the main script.  We use it to
// determine if the main script has restarted, and if so, we reset our gmem
// index and await a new assignment.
GMEM_GIDX_SERIAL = 2;
// A bitmap that tracks available RFX instance ids, used to calculate our
// gmem_index.  See gmem_allocate().
GMEM_GIDX_ID_BITMAP_OFFSET = 3;
// The default channel used by the main app.  Cached in default_channel.
GMEM_GIDX_DEFAULT_CHANNEL = 4;
GMEM_GIDX_RFX_OFFSET = 5;
GMEM_GIDX_RFX_STRIDE = 6;


// Offset for sequence of opcodes relative to gmem_index (see OPCODE_*).
//
// Slot 0 at this offset is the size of the committed opcode queue length, while
// slot 1 is the size of the uncommitted queue length.
//
// Afterward there are 1 or more opcode records.  See OPCODE_* below for more.
GMEM_GIDX_OPCODES_OFFSET = 20;
// Offset for data dumps from the main app relative to gmem_index.
GMEM_GIDX_APP_DATA_OFFSET = 21;

// Offset for start of RFX instance data.  The arrangement of the instance data
// is dependent on RFX_VERSION.
//
// When the serial portion of slider1 (byte 0) changes, the main script will
// read the instance data.  The arrangement of instance data attempts to be
// extensible and forward compatible, and there is some optimization to ensure
// the main script doesn't need to read everything.
//
// RFX_VERSION 2
//
//   slot 0: bitmap of things that have changed.  RFX sets, main script clears.
//     bit 0: unused
//     bit 1: active notes
//     bit 2: programs
//     bit 3: CCs for default channel
//
//    slots 1-32: each of these slots contains an offset within the instance
//                data buffer for the type of data described by bits 1-31 of
//                slot 0.  Offset is encoded in bits 0-15 and length in bits
//                16-31.
//
//   slot[slot[1] & 0xffff] (active notes):
//   - Bitmap of MIDI channels with active (held) notes.  Used by the
//     GUI to indicate activity on channels.
//
//   slot[slot[2] & 0xffff] (programs):
//    - groups of 16 slots that define programs on group n
//      slot 0: program for channel 1 on group 1
//      slot 1: program for channel 2 on group 1
//      ...
//      slot 15: program for channel 16 group 1
//
//      This arrangement allows support of more than 4 groups.  It's a bit
//      wasteful in that we're leaving bits 9-31 unused but that space can
//      be used for future purposes, and with the gmem buffer we aren't as
//      constrained for space as we were with sliders.
//
//   slot[slot[3] & 0xffff] (CC):
//    - 128 slots, where each slot[n] represents the value for CC n on
//      the default channel.

GMEM_GIDX_INSTANCE_DATA_OFFSET = 22;


// A bitmap of things the main script is interested in having us process, such
// as writing certain instance data, feedback to controller, etc.  (Current
// programs is implied.)
GMEM_GIDX_SUBSCRIPTION_OFFSET = 23;


// Starting at slot 3 of opcodes gmem region are 1 or more opcode record.
// An opcode record consists of 1 or more slots where:
//       Slot 0: bits 0-7 is the opcode and bits 8-15 are the number of args
//    Slot 1..n: opcode arguments where n is the number of args
//               depending on the opcode
//
// As this is stored in the gmem buffer, each slot is a 32-bit value.
//

// Most of the opcode parameters assume only 8-bit sizes rather than
// 32 bits, which is a relic of a previous design.  This can be optimized
// in the future.


// DEPRECATED: do nothing.
OPCODE_NOOP = 0;

// Clear all configuration (articulations, etc.).  If reset is non-zero, then
// current programs will also be reset (TODO).
// (reset)
OPCODE_CLEAR = 1;

// Activates the articulation on the given channel.
// (channel, program)
OPCODE_ACTIVATE_ARTICULATION = 2;

// Allocates a new articulation.  Subsequent SET_ARTICULATION_* opcodes will
// refer to this articulation.  Value is a bitmap where the first 4 bits are
// the group number and the next 4 bits indicate the number of output
// events that will follow.
//
// (channel+version, program, value)
OPCODE_NEW_ARTICULATION = 3;

// (flags, off program, unused)
OPCODE_SET_ARTICULATION_INFO = 4;

// (type+dstchannel, param1, param2)
OPCODE_ADD_OUTPUT_EVENT = 5;

// Syncs current state to the MIDI bus defined in OPECODE_SET_CC_FEEDBACK_ENABLED.
// The first argument is a bitmap indicating what should be synced.
//    bit 0: sync CCs
//    bit 1: sync articulations
//
// (what)
OPCODE_SYNC_TO_FEEDBACK_CONTROLLER = 7;

// Sets whether CC feedback should be enabled.  If 0 (which is the default
// unless set to 1), OPCODE_SYNC_TO_FEEDBACK_CONTROLLER is a no-op.
// (enabled, bus)
OPCODE_SET_CC_FEEDBACK_ENABLED = 8;

// Creates a new bank.  Any articulation created with OPCODE_NEW_ARTICULATION
// is assumed to belong to this bank.
//
// (channel+version, msb, lsb)
OPCODE_NEW_BANK = 9;

// Defines a new CC to be chased for the bank that was previously created with
// OPCODE_NEW_BANK.  Called separately for each CC that is to be chased.
// These CCs are ignored per articulation if ARTICULATION_FLAG_CHASE is not
// set.
//
// (cc)
OPCODE_SET_BANK_CHASE_CC = 10;

// Sets additional parameters for the last output event added with
// OPCODE_ADD_OUTPUT_EVENT.  Requires an articulation record version of
// 1 or later.
//
// (filter_program)
OPCODE_SET_OUTPUT_EVENT_INFO1 = 11;

// Sets the opaque app data.  No arguments are needed: all details are
// stored in the gmem offset for appdata.
// ()
OPCODE_SET_APPDATA = 12;

// Unsets the current articulation for the given channel and group.
//
// (channel, group)
OPCODE_CLEAR_ARTICULATION = 13;

// Push current program state onto the history stack based on the current value
// of the undo serial slider.  We watch for changes to the undo serial slider
// to detect when an undo has occurred.
// ()
OPCODE_PUSH_HISTORY = 14;

// Updates the gmem instance data region with the current state of the CCs.
// Called by the main script when the main script when the default channel
// changes.
// ()
OPCODE_UPDATE_CURRENT_CCS = 15;


// Sets the things we need to update the gmem instance data for (active
// notes, CCs, etc.).  See SUBSCRIPTION_* constants below.  Enabling a
// subscription will cause an immediate sync to the instance data.
//
// (subscription_bitmap)
OPCODE_SUBSCRIBE = 16;


// Constants that apply to the flags parameter for OPCODE_SET_ARTICULATION_INFO
ARTICULATION_FLAG_CHASE = 1 << 0;
ARTICULATION_FLAG_ANTIHANG = 1 << 1;
ARTICULATION_FLAG_ANTIHANG_CC = 1 << 2;
ARTICULATION_FLAG_BLOCK_BANK_CHANGE = 1 << 3;
ARTICULATION_FLAG_TOGGLE = 1 << 4;
ARTICULATION_FLAG_HIDDEN = 1 << 5;
ARTICULATION_FLAG_IS_FILTER = 1 << 6;

// Constants that refer to the low nybble of the type+dstchannel parameter
// for OPCODE_ADD_OUTPUT_EVENT
OUTPUT_TYPE_NONE = 0;
OUTPUT_TYPE_PROGRAM = 1;
OUTPUT_TYPE_CC = 2;
OUTPUT_TYPE_NOTE = 3;
OUTPUT_TYPE_NOTE_HOLD = 4;
OUTPUT_TYPE_ARTICULATION = 5;


// Constants for the subscription bitmap for OPCODE_SUBSCRIBE.
SUBSCRIPTION_NONE = 0;
SUBSCRIPTION_CC = 1 << 0;
SUBSCRIPTION_NOTES = 1 << 1;


// LSB of slider 1
change_serial = -1;
// If 1, increments the change_serial at the end of @block
queue_increment_serial = 0;


undo_serial = -1;

// The global instance number of this RFX.  Initialized in @serialize
instance_id = -1;
// The gmem offset for communication with the main script.  All instances
// share the gmem buffer, and each instance gets its own space in the buffer.
// There are 8M 32-bit slots available in the gmem buffer.  The main script
// sets our gmem index by updating slider 2.
gmem_index = 0;

// gmem[GMEM_GIDX_SERIAL] is set by the main script and is a monotonically
// increasing serial (wall clock basically).  gmem_serial is a copy of this
// value at the time gmem_index is initialized.  If at any time
// gmem[GMEM_GIDX_SERIAL] != gmem_serial then it means the main script has
// restarted.
gmem_serial = 0;
gmem_version = 0;

// 0 = stored data not yet deserialized, JSFX not initialized
// 1 = stored data deserialized, gmem index alocated
// 2 = First execution of @block has occurred
instantiating = 0;

// Persisted, and tracks the version of the serialized instance data
serialized_version = 0;

// Array to map source channel to destination channels.  Value is a 16-bit
// bitmap where each bit is a MIDI channel.
channel_map = 20000;  // size: 16

// Placeholder for old version of held_keyswitches
_dummy = 21000;

// Used for opcode-based articulation activation. Tracks by MIDI channel
// what the requested articulation is.  @slider section handles updating
// this array, and @block will execute on next invocation.
//
// The value is the has the requested program for the channel in b0 and b1
// contains 0x01 if the activation has yet to occur, or 0x02 if it occurred.
// This is needed to filter duplicate program changes.
pending_activations = 20200; // size: 16
// Non-zero if the pending_activations array needs to be enumerated
// on the next @block.
have_pending_activations = 0;

last_play_state = 0;

// Array to track active notes per channel.  Each channel is a bitmap of 5 adjacent
// 31-bit integers where each bit is a note.  (31 bits due to obnoxious signed issue.)
// This is used by the GUI to show activity on MIDI channels.
active_notes_by_channel = 20300; // size: 16*5 = 80

// Array to track which destination channel on which a note is active for a
// given source channel.  Indexed by source channel and note number, and the
// value has 2 slots although only the first is used: it holds a bitmap for
// the 16 dest channels, and the active articulation when the note was pressed.
//
// This is used to for anti note hanging.  When a note-on event is observed
// on a given source channel, the RFX tracks the destination channel the
// event was ultimately routed to.  We ensure that subsequent note-offs coming
// in on the same channel will be sent to the channel the note was routed to.
active_dstchannels_by_note = 20400; // size: 16 * 128 * 2 = 4096

// Array to track which destination channels on which a CC is active for a
// given source channel.  Indexed by source channel and CC number, and
// the value is a bitmap for all destination channels that we sent a non-zero
// CC value to.
//
// This is used for anti CC hanging (for CC 2, 64, and 66).  A channel
// is only added to the bitmap when the currently active articulation has
// the antihangcc flag enabled at the time the CC event occurred.  When
// we see a zero-value CC, we then replay that event on all destination
// channels.
active_channels_by_cc = 25000; // size: 16 * 128 = 2048


// Tracks last CC values received on a given channel.  Indexed by MIDI channel
// and CC number, and value is the last seen CC value.  A value of -1 indicates
// that no CC was seen.
//
// This is used for CC chasing and CC feedback.
last_ccs_by_channel = 30000; // size: 16 * 128 = 2048

// Bits 0-3 indicate the MIDI bus for feedback.  Bit 7 is whether feedback
// is enabled.
midi_feedback = 0;
// If non-zero, indicates on next @block we should sync to the feedback bus.
// Value represents a bitmap as defined in OPCODE_SYNC_TO_FEEDBACK_CONTROLLER
// above.
midi_feedback_sync_pending = 0;

// Indexed by source channel, values hold the union of articulation
// flags for articulations across all groups for that channel.  Used to make
// behaviour decisions (e.g. CC chasing): if any active articulation on any
// group for the channel needs the behaviour, then it will happen.
all_articulation_flags_by_channel = 32500; // size: 16


// Length of the articulations array.
articulations_len = 0;

// Array that maps a program to the appropriate position in the articulations
// array.  Indexed by MIDI channel (byte 1) and program number (byte 0).  A value
// of -1 indicates this program/channel combination has no assigned articulation.
//
// This value is maintained and persisted but it's not otherwise used directly.
// Instead it's translated to articulations_ptr to provide a directly useable
// pointer to an articulation in this JSFX instance.
//
// JS serialization munges the MSB but 24 bits is still plenty big to
// represent an offset.
articulations_offsets = 33000;  // size: 16 * 128 = 2048

// Array that maps a program to the appropriate position in the articulations
// array.  Indexed by MIDI channel and program number.
articulations_ptr = 40000; // size: 16 * 128 = 2048


// Array holding all configured articulations.  This array holds variable
// sized records, whose size varies by articulation and depends on factors
// such as the articulation record version and number of output events.
//
// The record version is indicated in slot 1 bits 4-7 where the following
// versions are defined:
//
//     v0: each record is 2 + n slots, where n is the # of output events.
//     v1: each record is 3 + 2n slots, where n is the # of output events.
//
// This array is indexed via articulations_ptr.
//
// Slot 0: v0+ - articulation information
//      bits 0-3: number of output events (see below)
//      bits 4-7: group number
//        byte 1: articulation flags
//        byte 2: "off" (release) program for articulations with note-hold outputs.
//
// Slot 1: v0+
//      bits 0-3: source channel
//      bits 4-7: articulation record version
//     bytes 1-2: indicates the offset (from 0) into the banks array this
//                articulation belongs to.
//
// TODO: https://github.com/jtackaberry/reaticulate/issues/72
// Slot 2: v1+ - reserved for future expansion
// Slot 3-?: v2+

//
// Following the base articulation information slots, there are n*m slots for
// output events, where n is the # of output events and m is dependent on
// the articulation record version.
//
// Slot 0: v0+
//      bits 0-3: output type (see OUTPUT_TYPE_* constants)
//      bits 4-7: the destination MIDI channel for the articulation.  Subsequent
//                incoming events are routed to this channel when the articulation
//                is activated, in addition to output event.
//     bits 8-14: parameter 1 (context depends on output type)
//        bit 15: if set, this output event should not setup channel routing
//    bits 16-22: parameter 2 (context depends on output type)
//        bit 23: if set, use current routing for destination and ignore
//                bits 4-7
// Slot 1: v1+
//      bits 0-6: filter program number: if this program isn't already activated
//                in another group on the same channel, then the output event
//                will not be emitted.
//         bit 7: if set, filtering will be performed.
// TODO: https://github.com/jtackaberry/reaticulate/issues/73
//     bits 8-11: the MIDI bus number for the articulation (0 = bus 1).
//                v0 output events are always on bus 1.
// TODO: https://github.com/jtackaberry/reaticulate/issues/74
//        bit 12: if set, send to all MIDI channels on the defined bus.
// TODO: https://github.com/jtackaberry/reaticulate/issues/10
//    bits 13-19: parameter 2 upper limit (if 0, then not a range)
//

articulations = 200000; // size: (3 + 16*2) * 128 * 16 = 71680 (upper bound for v1)

// The last articulation created by OPCODE_NEW_ARTICULATION.
last_new_articulation = 0;

// The latest output event creater by OPCODE_ADD_OUTPUT_EVENT.
last_new_output_event = 0;

// Maps output events to articulations.  The first 24 bits of the value is a
// pointer to the articulation, and the MSB holds the output event number of
// the articulation.
//
// Index numbers are a bit clever to save space: the first 128 elements
// represent program changes, the next 128 represent notes (velocity is
// intentionally ignored for now), and the next 128*128 are for CCs
// (CC # and value).  All those 16640 elements are repeated for all 16
// source MIDI channels.
//
// NB: normally the high byte is obliterated during serialization, but we'll use it
// here because this array is not serialized.  It's regenerated on instantiation.
articulations_by_output_event = 300000; // size: (256 + 128 * 128) * 16 = 266240

// Maps an articulation index to the program and channel number for
// that articulation.  Byte 0 (LSB) contains the program number and bits 0-3 of
// byte 1 contains the channel.
//
// Regenerated on instantiation.
program_by_articulation = 600000; // size: (2 + 16) * 128 * 16 = 36864 (upper bound)



// When activate() is called, keeps track of all articulation programs that were
// triggered to prevent infinite recursion (by means of art output event types).
// This is 4 slots where each slot is a 32-bit bitmap, representing all 128
// programs.
activated_programs = 640000; // size: 4



// Given a source channel and group number, we need to identify currently held
// keyswitch notes and the destination channels the note-on event was sent to
// for the note-off deferral.
//
// A confounding factor is that each individual note in a (channel, group) tuple
// could have a different set of destination channels (the 16-bit dstchannel bitmap)
// Moreover, we need to persist this, so only 24-bits of each array slot is usable.
//
// If we just used 128 slots per (channel, group) indexed by note number whose
// value was the dstchannel bitmap for that note, then we'd need 128*16*4=8192
// slots in total.  And then we'd need to iterate over all 128 when sending the
// deferred note-off for a group.
//
// So let's make some compromises here.  How many note-hold output events are
// we likely to have active in a group in a given moment?  I'm calling it 8.
// We can support 8 concurrent held notes per (channel, group) tuple.
//
// This array is indexed by (channel, group) where each record has 8*2 slots.
// Each held note uses 2 slots.
//
// Slot 0: LSB of value contains the note number, and next 8 bits contains
//         the velocity the note-on was sent at, in case it needs to be
//         retriggered.  A value of 0 means no note was held at this slot.
// Slot 1: Low 16-bits contains the dstchannels bitmap.

// There will be no gaps, so if the first slot is 0, then there are no held
// keyswitches for that channel/group.
held_keyswitches = 650000; // size: 16 * MAX_GROUPS * 8 * 2 = 1024

// Length of the banks array.
banks_len = 0;

// Array holding all configured banks.  This array holds variable
// sized records, whose size depends on the bank record version.
//
// The record version is indicated in slot 0 bits 4-7 where the following
// versions are defined:
//
//     v0: each record is 10 slots
//
// Slot 0: v0 - bank information
//      bits 0-3: source channel
//      bits 4-7: bank record version
//        byte 1: bank MSB
//        byte 2: bank LSB
// Slot 1: v0 - CC chase bitmap for CCs 0-23
// Slot 2: v0 - CC chase bitmap for CCs 24-47
// Slot 3: v0 - CC chase bitmap for CCs 48-72
// Slot 4: v0 - CC chase bitmap for CCs 72-95
// Slot 5: v0 - CC chase bitmap for CCs 96-119
// Slot 6: v0 - CC chase bitmap for CCs 120-127
// Slots 7-9: unused
banks = 660000; // size: MAX_CHANNELS * MAX_BANKS * 10 = 2560

// The last articulation created by OPCODE_NEW_BANK.
last_new_bank = 0;


// Last PC mpos delta by channel.  Events must be offset by this amount to ensure they
// follow articulation output events.
program_change_mpos_delta = 670000; // size: 16

// Current programs on each channel indexed by group.  Arranged in sets of 4
// consecutive slots, with each set of 4 representing a different articuulation
// group.  The 4 slots hold the program number for 16 MIDI channels.  See
// GMEM_GIDX_INSTANCE_DATA_OFFSET above as the arrangement is the same.
current_programs = 670100;
current_programs_len = 16 * MAX_GROUPS;

// Length of appdata array.
appdata_len = 0;
// Length of original appdata passed by app before having been expanded
// to avoid MSB clobbering caused by JS serialization.
appdata_orig_len = 0;

// This appdata is serialized.
appdata = 680000;  // size:  40000 (upper bound)

// Maps undo serial (index) to the position in the undo_history array.
// We support 100 different undo history states.  This is treated as a
// ring buffer.
HISTORY_SLOT_SIZE = current_programs_len;
undo_history = 1000000 + MAX_UNDO_SLOTS;

// Bitmap of SUBSCRIPTION_* constants based on last OPCODE_SUBSCRIBE
subscriptions = SUBSCRIPTION_NONE;



function increment_serial()
(
    change_serial = (change_serial + 1) % 256;
    slider1 = RFX_MAGIC | RFX_VERSION | (slider1 & 0x0000ff00) | change_serial;
    sliderchange(1);
);


function get_articulation_version_record_size(version)
(
    (version == 0) ? 2 : (
        (version == 1) ? 3;
    );
);

function get_articulation_version_output_event_size(version)
(
    (version == 0) ? 1 : (
        (version == 1) ? 2;
    );
);

function get_bank_version_record_size(version)
(
    10;
);

function get_bank_source_channel(bank)
(
    bank[0] & 0x0f;
);

function get_bank_msb(bank)
(
    (bank[0] >> 8) & 0xff;
);

function get_bank_lsb(bank)
(
    (bank[0] >> 16) & 0xff;
);



function update_output_event_map(type, b1, b2, articulation, event_idx)
local(idx, channel)
(
    idx = -1;
    (type == OUTPUT_TYPE_NOTE || type == OUTPUT_TYPE_NOTE_HOLD) ? (
        idx = 128 + b1;
    ) : (
        (type == OUTPUT_TYPE_CC) ? (
            idx = 256 + (b1 * 128) + b2;
        ) : (
            (type == OUTPUT_TYPE_PROGRAM) ? (
                idx = b1;
            );
        );
    );
    (idx != -1) ? (
        channel = articulation[1] & 0x0f;
        idx += (256 + 128 * 128) * channel;
        articulations_by_output_event[idx] = articulation + (event_idx << 24);
    );
);


function get_articulation(channel, program)
(
    articulations_ptr[channel * 128 + program];
);


function get_active_program(channel, group)
local(program)
(
    program = current_programs[(group * MAX_CHANNELS) + channel];
    program == 128 ? -1 : program;
);

function is_program_active(channel, program)
(
    get_active_program(channel, 0) == program ||
    get_active_program(channel, 1) == program ||
    get_active_program(channel, 2) == program ||
    get_active_program(channel, 3) == program;
);



function get_active_articulation(channel, group)
local(program)
(
    program = get_active_program(channel, group);
    (program != -1) ? get_articulation(channel, program) : 0;
);


function get_articulation_program(articulation)
(
    program_by_articulation[articulation - articulations] & 0xff;
);


function get_articulation_num_outputs(articulation)
(
    articulation[0] & 0x0f;
);


function get_articulation_group(articulation)
(
    (articulation[0] & 0xf0) >> 4;
);


function get_articulation_flags(articulation)
(
    (articulation[0] & 0xff00) >> 8;
);


function get_articulation_off_program(articulation)
(
    (articulation[0] & 0x7f0000) >> 16;
);


function get_articulation_channel(articulation)
(
    articulation[1] & 0x0f;
);

function get_articulation_version(articulation)
(
    (articulation[1] & 0xf0) >> 4;
);

function get_articulation_bank(articulation)
(
    ((articulation[1] & 0xffff00) >> 8) + banks;
);


function get_articulation_output_event_offset(articulation, n)
local(version)
(
    version = get_articulation_version(articulation);
    get_articulation_version_record_size(version) + get_articulation_version_output_event_size(version) * n;
);


function get_articulation_record_size(articulation)
(
    get_articulation_output_event_offset(articulation, get_articulation_num_outputs(articulation));
);


function get_articulation_output_event(articulation, n)
(
    articulation + get_articulation_output_event_offset(articulation, n);
);


function get_output_event_type(event)
(
    event[0] & 0x0f;
);


function get_output_event_dstchannel(event)
(
    (event[0] & 0xf0) >> 4;
);


function get_output_event_param1(event)
(
    (event[0] & 0x7f00) >> 8;
);


function get_output_event_param2(event)
(
    (event[0] & 0x7f0000) >> 16;
);

function get_output_event_should_route(event)
(
    !(event[0] & 0x8000);
);

function get_output_event_use_current_routing(event)
(
    (event[0] & 0x800000) != 0;
);


// Returns -1 if no filtering.
function get_output_event_filter_program(event)
(
    // Requires v1+ articulations, but does not do a version test.
    (event[1] & 0x80) ? (
        event[1] & 0x7f;
    ) : (
        -1;
    );
);


function gmem_write_current_ccs()
local(offset, poffset, channel, i)
(
    offset = gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET];
    poffset = offset + (gmem[offset + 3] & 0xff);
    channel = gmem[GMEM_GIDX_DEFAULT_CHANNEL];
    i = 0; loop(128,
        gmem[poffset + i] = last_ccs_by_channel[channel * 16 + i];
        i += 1;
    );
    gmem[offset] |= (1 << 3);
);

function gmem_write_current_programs()
local(offset, poffset, i)
(
    offset = gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET];
    // Write current programs to gmem buffer.
    poffset = offset + (gmem[offset + 2] & 0xff);
    i = 0; loop(current_programs_len,
        gmem[poffset + i] = current_programs[i];
        i += 1;
    );
    gmem[offset] |= (1 << 2);
);


function gmem_write_active_notes()
local(offset, bitmap, notes, i)
(
    bitmap = 0;
    notes = active_notes_by_channel;
    i = 0; loop(16,
        (notes[0] || notes[1] || notes[2] || notes[3] || notes[4]) ? (
            bitmap |= (1 << i);
        );
        i += 1;
        notes += 5;
    );

    offset = gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET];
    (gmem[offset + 33] != bitmap) ? (
        gmem[offset + 33] = bitmap;
        gmem[offset] |= (1 << 1);
        // Return 1 to indicate active notes bitmap changed.
        1;
    ) : (
        // Return 0 to indicate active notes bitmap did not change.
        0;
    );
);

// This function initializes the instance's region in the gmem buffer, and
// assumes a gmem instance index has already been allocated via gmem_allocate(),
function gmem_init()
local(offset, poffset, i)
(
    slider2 = gmem_index;
    gmem_serial = gmem[GMEM_GIDX_SERIAL];

    // ping = gmem[gmem_index + 2];
    // gmem[gmem_index + 2] = ping + 1;

    // Copy user data.  memcpy() does *not* work for gmem buffers.
    offset = gmem_index + gmem[GMEM_GIDX_APP_DATA_OFFSET];
    gmem[offset + 0] = 1;
    gmem[offset + 1] = appdata_orig_len;
    gmem[offset + 2] = appdata_len;
    i = 0; loop(appdata_len,
        gmem[offset + 3 + i] = appdata[i];
        i += 1;
    );

    //
    // Write instance data to notify main script of current programs, CCs, etc.
    //
    offset = gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET];

    // First store offsets so main script knows where to look
    //
    // Active notes: size is just 1 slot
    gmem[offset + 1] = (33) | (1 << 16);
    // Current programs.  Size is 16 slots per group * MAX_GROUPS
    gmem[offset + 2] = (33 + 1) | ((MAX_CHANNELS * MAX_GROUPS) << 16);
    // Current CCs on default channel.  Size is 128 slots (for 128 CCs).
    gmem[offset + 3] = (33 + 1 + (MAX_CHANNELS * MAX_GROUPS)) | (128 << 16);

    gmem_write_current_programs();
    gmem_write_current_ccs();
);



// Allocate a gmem index for this instance.
//
// The first order of business is to determine a unique instance id.  The
// gmem buffer contains 100 slots for this purpose, acting as a giant
// 3200 bit wide bitmap.  This means we can support up to 3200 RFX instances
// across all currently loaded projects.  Should be enough. ;)
//
// We use an atomic test-and-set to reserve one of the instance slots, after
// which time we update slider2 with the gmem index (via gmem_init() above).
// At that point the main app is able to communicate with us via our gmem
// instance region.
//
// The JSFX only ever reserves ids.  We rely on the main script to periodically
// scan all current RFX instances and zero bits that refer to dead instances.
// See rfx.gc() in the main app for more details.
function gmem_allocate()
local(version, offset, i, bitmap, bit, curval)
(
    version = gmem[GMEM_GIDX_VERSION];
    (version != gmem_version && gmem[GMEM_GIDX_MAGIC] == GMEM_MAGIC) ? (
        // Find first available instance id.
        offset = gmem[GMEM_GIDX_ID_BITMAP_OFFSET];
        i = 0;
        while (instance_id == -1 && i < 100) (
            bitmap = gmem[offset + i];
            (bitmap != 0xffffffff) ? (
                // There is at least one available instance id at this slow.
                bit = 0;
                while (instance_id == -1 && bit < 32) (
                    (bitmap & (1 << bit) == 0) ? (
                        // We found an available instance idea.  Try to claim it.
                        curval = atomic_setifequal(gmem[offset + i], bitmap, bitmap | (1 << bit));
                        (curval == bitmap) ? (
                            // The candidate instance id is now claimed.
                            instance_id = i * 32 + bit;
                        );
                    );
                    bit += 1;
                );
            );
            i += 1;
        );
        (instance_id != -1) ? (
            gmem_index = gmem[GMEM_GIDX_RFX_OFFSET] + (instance_id * gmem[GMEM_GIDX_RFX_STRIDE]);
            gmem_version = version;
            gmem_init();
        ) : (
            // No available slots.
            gmem_index = 0;
            gmem_serial = 0;
            gmem_version = 0;
        );
    );
);

function exec_opcode(opcode, a0, a1, a2, argc, argi)
local(offset, bitmap, channel, num_outputs, event, program_offset, offset, version, i)
(
    (opcode == OPCODE_CLEAR) ? (
        // Nuke it all from orbit.
        memset(all_articulation_flags_by_channel, 0, 16);
        memset(articulations_offsets, -1, 16 * 128);
        memset(articulations_ptr, 0, 16 * 128);
        memset(articulations, 0, (2 + 16) * 128 * 16);
        memset(articulations_by_output_event, 0, (256 + 128 * 128) * 16);
        memset(program_by_articulation, 0, (2 + 16) * 128 * 16);
        memset(banks, 0, MAX_CHANNELS * MAX_BANKS * 10);
        articulations_len = 0;
        last_new_articulation = 0;
        last_new_output_event = 0;
        banks_len = 0;
        last_new_bank = 0;
    );

    // Arguments: (channel+version, msb, lsb)
    (opcode == OPCODE_NEW_BANK) ? (
        channel = a0 & 0x0f;
        version = (a0 & 0xf0) >> 4;
        last_new_bank = banks + banks_len;

        // Now that the space is reserved, reset the events counter which we
        // increment for each new event.
        last_new_bank[0] = a0 | (a1 << 8) | (a2 << 16);
        banks_len += get_bank_version_record_size(version);
    );


    // Arguments: (cc)
    (opcode == OPCODE_SET_BANK_CHASE_CC) ? (
        offset = floor(a0 / 24);
        bitmap = 1 << (a0 - (offset * 24));
        last_new_bank[1 + offset] |= bitmap;
    );


    // Arguments: (channel+version, program, num groups/outputs)
    (opcode == OPCODE_NEW_ARTICULATION) ? (
        channel = a0 & 0x0f;
        // Number of events we need to reserve.
        num_outputs = a2 & 0x0f;
        last_new_articulation = articulations + articulations_len;

        // Map new articulation to program/channel.
        program_by_articulation[articulations_len] = a1 | (channel << 8);

        articulations_offsets[channel * 128 + a1] = last_new_articulation - articulations;
        articulations_ptr[channel * 128 + a1] = last_new_articulation;

        // Now that the space is reserved, reset the events counter which we
        // increment for each new event.
        last_new_articulation[0] = a2 & 0xf0;
        last_new_articulation[1] = a0 | (banks_len << 8);
        articulations_len += get_articulation_output_event_offset(last_new_articulation, num_outputs);

        last_new_articulation[0] = (last_new_articulation[0] & 0x7f0000ff) |
                                   (gmem[argi + 3] << 8) | (gmem[argi + 4] << 16);
    );

    // Arguments: (type+dstchannel, param1+noroute, param2+currentroute)
    (opcode == OPCODE_ADD_OUTPUT_EVENT) ? (
        // Get current number of output events for articulation to act as the index for the
        // one being added now.
        num_outputs = get_articulation_num_outputs(last_new_articulation);

        // Get pointer to current output event.
        event = last_new_articulation + get_articulation_record_size(last_new_articulation);
        last_new_output_event = event;
        event[0] = a0 | (a1 << 8) | (a2 << 16);

        // v1 output events have additional options
        get_articulation_version(last_new_articulation) >= 1 ? (
            // filter program + filter enabled
            event[1] = gmem[argi + 3];
        );

        // Increment events count.
        last_new_articulation[0] = (last_new_articulation[0] & 0x7ffffff0) + (num_outputs + 1);

        // Map output event back to articulation
        update_output_event_map(a0 & 0x0f, a1, a2 & 0x7f, last_new_articulation, num_outputs);
    );

    // Arguments: (channel, program)
    (opcode == OPCODE_ACTIVATE_ARTICULATION) ? (
        // FIXME: this needs to support multiple groups per channel
        // 0x01 in byte 1 indicates the program requires activation.
        pending_activations[a0] = a1 | 0x0100;
        have_pending_activations = 1;
    );

    // Arguments: (channel group)
    (opcode == OPCODE_CLEAR_ARTICULATION) ? (
        program_offset = (a1 * MAX_CHANNELS) + a0;
        current_programs[program_offset] = 128;

        offset = gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET];
        gmem[offset + 34 + program_offset] = 128;
        gmem[offset] |= (1 << 2);
        queue_increment_serial = 1;
    );

    // Arguments: (what)
    (opcode == OPCODE_SYNC_TO_FEEDBACK_CONTROLLER) ? (
        midi_feedback_sync_pending |= a0;
    );

    // Arguments: (enabled, bus)
    (opcode == OPCODE_SET_CC_FEEDBACK_ENABLED) ? (
        midi_feedback = (a1 & 0x0f) | (!!a0 << 4);
    );

    // Arguments: none
    (opcode == OPCODE_SET_APPDATA) ? (
        offset = gmem_index + gmem[GMEM_GIDX_APP_DATA_OFFSET];
        version = gmem[offset + 0];
        (version == 1) ? (
            appdata_orig_len = gmem[offset + 1];
            appdata_len = gmem[offset + 2];
            i = 0; loop(appdata_len,
                appdata[i] = gmem[offset + 3 + i];
                i += 1;
            );
        );
    );

    // Arguments: none
    (opcode == OPCODE_PUSH_HISTORY) ? (
        memcpy(undo_history + (slider62 * current_programs_len), current_programs, current_programs_len);
        slider62 = (slider62 + 1) % MAX_UNDO_SLOTS;
        undo_serial = slider62;
        sliderchange(62);
    );

    // Arguments: none
    (opcode == OPCODE_UPDATE_CURRENT_CCS) ? (
        gmem_write_current_ccs();
        queue_increment_serial = 1;
    );

    // Arguments: (bitmap of SUBSCRIPTION_* values)
    (opcode == OPCODE_SUBSCRIBE) ? (
        (a0 & SUBSCRIPTION_CC != 0 && subscription & SUBSCRIPTION_CC == 0) ? (
            gmem_write_current_ccs();
        );
        (a0 & SUBSCRIPTION_NOTES != 0 && subscription & SUBSCRIPTION_NOTES == 0) ? (
            gmem_write_active_notes();
        );
        (a0 != subscription) ? (
            subscription = a0;
            queue_increment_serial = 1;
        )
    );
);


function process_pending_opcodes()
local(idx, n_opcodes, queue_size, argc)
(
    (gmem_index > 0) ? (
        idx = opidx = gmem_index + gmem[GMEM_GIDX_OPCODES_OFFSET];
        queue_size = gmem[idx];
        (queue_size > 0) ? (
            // First two slots in the opcode region are commited length and pending length.
            // Skip over those.
            idx += 2;
            while (queue_size > 0) (
                // Number of arguments for this opcode
                argc = (gmem[idx + 0] >> 8) & 0xff;
                // Execute the opcode, passing the first 3 directly as they are the most common,
                // and then passing the gmem index for the opcode args in case more need to
                // be accessed.
                exec_opcode(gmem[idx + 0] & 0xff, gmem[idx + 1], gmem[idx + 2], gmem[idx + 3], argc, idx + 1);
                // Increment index by the number of arguments plus 1 for the opcode itself
                idx += argc + 1;
                queue_size -= argc + 1;
            );
            // Zero out committed opcode queue size.  This unblocks main app
            // from enqueuing more opcodes.
            gmem[opidx] = 0;
        );

        /*
        n_opcodes = gmem[idx];
        (n_opcodes > 0) ? (
            gmem[idx] = 0;
            idx += 2;
            loop(n_opcodes,
                exec_opcode(gmem[idx + 0], gmem[idx + 1], gmem[idx + 2], gmem[idx + 3]);
                idx += 4;
            );
        );
        */
    );
);


function process_undo(slot)
local(idx, offset, channel, group, program)
(
    idx = slot * current_programs_len;
    group = 0; loop(MAX_GROUPS,
        channel = 0; loop(MAX_CHANNELS,
            offset = (group * MAX_CHANNELS) + channel;
            program = undo_history[idx + offset];
            (program != current_programs[offset]) ? (
                current_programs[offset] = program;
                pending_activations[channel] = program | 0x0100;
                have_pending_activations = 1;
            );
            channel += 1;
        );
        group += 1;
    );
    gmem_write_current_programs();
    queue_increment_serial = 1;
);

@gfx
(slider9 || 1) ? (
    gfx_h = 400;
    gfx_x = gfx_y = 0;
    gfx_r = gfx_g = gfx_b = gfx_a = 1;
    channel = gmem[GMEM_GIDX_DEFAULT_CHANNEL];

    gfx_printf("Reaticulate debug info\n");
    gfx_printf("  serialized: reads=%d writes=%d   undo serial=%d   nundo=%d\n", nserr, nserw, undo_serial, nundo);
    gfx_printf("  metadata: %d\n", slider1);
    gfx_printf("  version: %d\n", serialized_version);
    gfx_printf("  serial: %d\n", change_serial);
    gfx_printf("  pending: %d\n", have_pending_activations);
    gfx_printf("  active notes bitmap: %d\n", gmem[gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET] + 33]);
    gfx_printf("  articulations len: %d\n", articulations_len);
    gfx_printf("  play state: %d %f\n", play_state, play_position);
    gfx_printf("  midi bus: %d\n", midi_feedback);
    gfx_printf("  banks_len: %d\n", banks_len);
    gfx_printf("  bank 0 chase 1: %d\n", banks[1]);

    gfx_printf("\nChannel %d debug info\n", channel + 1);
    group = 0; loop(MAX_GROUPS,
        program = get_active_program(channel, group);
        articulation = get_articulation(channel, program);
        num_outputs = get_articulation_num_outputs(articulation);
        flags = get_articulation_flags(articulation);
        idx = (MAX_GROUPS * MAX_HELD_KEYSWITCHES * 2 * channel) + (group * MAX_HELD_KEYSWITCHES * 2);
        group_held = held_keyswitches + idx;
        note = group_held[0] & 0xff;
        dstchannels = group_held[1] & 0xffff;
        bank = get_articulation_bank(articulation);
        gfx_printf("  %d: prog=%3d  art=%d outputs=%d flag=%3d held0=%2d ch %2d  cc=%d\n", group, program, articulation, num_outputs, flags, note, dstchannels, bank[1]);
        group += 1;
    );

    gfx_printf("\n\n");
    gfx_printf("instance=%d  gmem_index=%d  gmem_serial=%d\n", instance_id, gmem_index, gmem_serial);

    n_opcodes = gmem[gmem_index + gmem[GMEM_GIDX_OPCODES_OFFSET]];
    gfx_printf("gmem n_opcodes=%d\n", n_opcodes);
    gfx_printf("appdata: orig=%d serialied=%d offset=%d\n", appdata_orig_len, appdata_len, gmem_index + gmem[GMEM_GIDX_APP_DATA_OFFSET]);

    offset = gmem_index + gmem[GMEM_GIDX_APP_DATA_OFFSET];
    gfx_printf("current programs len: %d\n", current_programs_len);
    gfx_printf("default chan: %d\n", gmem[GMEM_GIDX_DEFAULT_CHANNEL]);
    gfx_printf("reinit: %d\n", instantiating);
);


@serialize
// Only serialize if we are writing, or if we're reading but also in the
// process of instantiating.  This prevents clobbering cached data from
// an ancient undo point.  This is important because Reaper stores undo
// state at Undo_EndBlock rather than Undo_BeginBlock().  Because we
// modify so much data in between undo blocks, we need to be cautious
// about deserialization.
//
// Sliders will of course be restoded no matter what.  We can detect an
// undo this way.
(file_avail(0) < 0 || instantiating <= 1) ? (
    file_var(0, serialized_version);
    file_mem(0, channel_map, 16);
    file_mem(0, _dummy, 16 * MAX_GROUPS); // old version of held_keyswitches
    file_mem(0, all_articulation_flags_by_channel, 16);
    file_mem(0, articulations_offsets, 16 * 128);
    file_var(0, articulations_len);
    file_mem(0, articulations, articulations_len);
    file_mem(0, last_ccs_by_channel, 16 * 128);
    file_var(0, midi_feedback);
    file_mem(0, held_keyswitches, 16 * MAX_GROUPS * MAX_HELD_KEYSWITCHES * 2);
    file_var(0, banks_len);
    file_mem(0, banks, banks_len);
    file_var(0, appdata_len);
    file_var(0, appdata_orig_len);
    file_mem(0, appdata, appdata_len);
    file_var(0, current_programs_len);
    file_mem(0, current_programs, current_programs_len);
    nserr += 1;

);

// This is done exactly once in the life of the RFX.
!serialized_version ? (
    serialized_version = 3;

    // Initialize MIDI channel routing and held keyswitches per channel
    memset(held_keyswitches, 0, 16 * MAX_GROUPS * MAX_HELD_KEYSWITCHES * 2);
    i = 0; loop(16,
        channel_map[i] = 1 << i;
        i += 1;
    );

    // Offset 0 is the first slot of the articulations array, so we initialize
    // all values to -1 which denotes the program/channel has no assigned
    // articulation.
    memset(articulations_offsets, -1, 16 * 128);

    // For chasing.  It's almost not worth persisting, but I have future plans. :)
    memset(last_ccs_by_channel, -1, 16 * 128);

    // Initialize current programs to no-program.
    memset(current_programs, 128, current_programs_len);
);


// This is done when the RFX is re-instantiated or during undo.
file_avail(0) >= 0 ? (
    //
    // Logic to perform migrations from previous RFX versions.
    //
    (serialized_version == 1) ? (
        // In version 1, articulations_offsets was actually an absolute position
        // instead of a relative one.  We need to convert it to a relative position
        // now as we'll generate articulations_ptr below.
        i = 0; loop(16 * 128,
            // 200000 was the position of articulations_ptr in v1
            articulations_offsets[i] -= 200000;
            i += 1;
        );
        serialized_version = 2;
    );
    (serialized_version == 2) ? (
        // In version 2, current programs were stored in sliders.  For v3 we
        // move them to a separate array and share via the gmem buffer.
        channel = 0; loop(16,
            control = slider(SLIDER_OFFSET_CONTROL + channel);
            current_programs[(0 * MAX_CHANNELS) + channel] = (control & 0x000000ff) >> 0;
            current_programs[(1 * MAX_CHANNELS) + channel] = (control & 0x0000ff00) >> 8;
            current_programs[(2 * MAX_CHANNELS) + channel] = (control & 0x00ff0000) >> 16;
            (slider26 & (1 << channel)) ? (
                current_programs[(3 * MAX_CHANNELS) + channel] = (control & 0xff000000) >> 24;
            ) : (
                current_programs[(3 * MAX_CHANNELS) + channel] = 128;
            );
            channel += 1;
        );
        serialized_version = 3;
    );

    (instantiating == 0) ? (
        // First initialization of JSFX.  Reset undo serial.
        slider62 = 0;
    );

    (slider62 != undo_serial) ? (
        // The undo slider doesn't match our cached undo serial, so an undo was
        // performed.  We maintain our own undo state (at least for program changes)
        // and can restore the program state from that undo serial.
        (undo_serial != -1) ? (
            process_undo(slider62);
            nundo += 1;
        );
        undo_serial = slider62;
    );

    // Regenerate articulations_ptr
    i = 0; loop(16 * 128,
        articulations_ptr[i] = articulations_offsets[i] + articulations;
        i += 1;
    );

    // Regenerate program_by_articulation
    memset(program_by_articulation, 0, (2 + 16) * 128 * 16);
    i = 0; loop(16 * 128,
        channel = i / 128;
        program = i % 128;
        offset = articulations_offsets[i];
        (offset != -1) ? (
            program_by_articulation[offset] = program | (channel << 8);
        );
        i += 1;
    );

    // Regenerate articulations_by_output_event
    memset(articulations_by_output_event, 0, (256 + 128 * 128) * 16);
    i = 0; while (i < articulations_len) (
        articulation = articulations + i;
        num_outputs = get_articulation_num_outputs(articulation);
        j = 0; loop(num_outputs,
            event = get_articulation_output_event(articulation, j);
            type = get_output_event_type(event);
            param1 = get_output_event_param1(event);
            param2 = get_output_event_param2(event);
            update_output_event_map(type, param1, param2, articulation, j);
            j += 1;
        );
        i += get_articulation_record_size(articulation);
    );

    // We're in a read (and by now will have restored all state), so allocate
    // and initialize the gmem buffer if necessary.
    (instance_id == -1) ? (
        gmem_allocate();
        instantiating = 1;
    );
) : (
    nserw += 1;
);

// The code below is executed on any instantiation or undo.
slider2 = gmem_index;
slider4 = instance_id;
sliderchange(2);
sliderchange(4);



@slider
// Opcode(s) triggered by the GUI.
slider64 = 0;
process_pending_opcodes();





@block
(instantiating == 1) ? (
    instantiating += 1;
);

gmem_allocate();
process_pending_opcodes();



function update_active_notes_for_gui(channel, note, note_on)
local(notes, bitmap, i, offset)
(
    // Update the note in the active notes array to reflect its
    // current note-on state.
    notes = active_notes_by_channel + (channel * 5);
    (note == -1) ? (
        notes[0] = notes[1] = notes[2] = notes[3] = notes[4] = note_on;
    ) : (
        bit = note % 31;
        (note_on) ? (
            notes[floor(note / 31)] |= (1 << bit);
        ) : (
            notes[floor(note / 31)] &= $~31 ~ (1 << bit);
        );
    );

    (subscription & SUBSCRIPTION_NOTES != 0) ? (
        gmem_write_active_notes() ? (
            queue_increment_serial = 1;
        );
    );
);

function update_current_ccs_for_gui(channel, cc, value)
local(offset, poffset)
(
    (gmem_index > 0 && channel == gmem[GMEM_GIDX_DEFAULT_CHANNEL]) ? (
        last_ccs_by_channel[channel * 16 + cc] = value;
        // Does main app care about this data?
        (subscription & SUBSCRIPTION_CC != 0) ? (
            offset = gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET];
            poffset = offset + (gmem[offset + 3] & 0xff);
            (value != gmem[poffset + cc]) ? (
                gmem[poffset + cc] = value;
                gmem[offset] |= (1 << 3);
                queue_increment_serial = 1;
            );
        );
    );
);

function update_current_channel_program(channel, new_program, group, flags)
local(control, shift, current_program, offset, program_offset, mask)
(
    // RFX v2 behavior
    program_offset = (group * MAX_CHANNELS) + channel;
    current_programs[program_offset] = new_program;

    offset = gmem_index + gmem[GMEM_GIDX_INSTANCE_DATA_OFFSET];
    // Size is 16 slots per group * MAX_GROUPS
    gmem[offset + 33 + 1 + program_offset] = new_program;
    gmem[offset] |= (1 << 2);

    queue_increment_serial = 1;
);


function midisend_multidst(mpos, dstchannels, basemsg1, msg2, msg3)
local(channel, bit)
(
    // A bit obtuse, but optimized for fewer/lower destination channels.
    // Stops looping once all destination channels have been hit.
    channel = 0;
    while (dstchannels) (
        bit = 1 << channel;
        (dstchannels & bit) ? (
            midisend(mpos, basemsg1 + channel, msg2, msg3);
            dstchannels &= $~16 ~ bit;
        );
        channel += 1;
        mpos += 1;
    );
    mpos;
);


function _set_held_keyswitch(noteinfo, param1, param2, dstchannel)
(
    noteinfo[0] = param1 | (param2 << 8);
    noteinfo[1] |= 1 << dstchannel;
);


// Returns 1 if successful (slot available) and 0 if no available slots.
function add_held_keyswitch(channel, group, param1, param2, dstchannel)
local (idx, dstchannels, group_held, i)
(
    idx = (MAX_GROUPS * MAX_HELD_KEYSWITCHES * 2 * channel) + (group * MAX_HELD_KEYSWITCHES * 2);
    group_held = held_keyswitches + idx;
    noteinfo = group_held;
    i = 0;
    // Optimize for the common case and assume first slot is free.
    !noteinfo[0] ? (
        _set_held_keyswitch(noteinfo, param1, param2, dstchannel);
    ) : (
        // First slot is taken, so find a free one.
        while (noteinfo[0] && i < MAX_HELD_KEYSWITCHES) (
            noteinfo += 2;
            i += 1;
        );
        (i < MAX_HELD_KEYSWITCHES) ? (
            _set_held_keyswitch(noteinfo, param1, param2, dstchannel);
            1;
        ) : (
            0;
        )
    );
);


function _send_held_keyswitch_note(mpos, channel, group, retrigger)
local(dstchannels, idx, group_held, i, note, dstchannels, velocity)
(
    idx = (MAX_GROUPS * MAX_HELD_KEYSWITCHES * 2 * channel) + (group * MAX_HELD_KEYSWITCHES * 2);
    group_held = held_keyswitches + idx;
    noteinfo = group_held;
    i = 0;
    // Push a sentinel.  Safely unique as the dstchannels bitmap (the lower 16 bits)
    // will never be 0.
    stack_push(0x42420000);
    // Send deferred note-offs for previously triggered keyswitches in this group.
    while (noteinfo[0] && i < MAX_HELD_KEYSWITCHES) (
        note = noteinfo[0] & 0xff;
        dstchannels = noteinfo[1] & 0xffff;
        mpos = midisend_multidst(mpos, dstchannels, MIDI_EVENT_NOTE_ON, note, 0);
        retrigger ? (
            velocity = (noteinfo[0] & 0xff00) >> 8;
            stack_push((note << 24) | (velocity << 16) | dstchannels);
        ) : (
            // Clear slot now that it's released.
            memset(noteinfo, 0, 2);
        );
        noteinfo += 2;
        i += 1;
    );

    // If retrigger is nonzero, the stack will contain note details for all notes
    // we now need to send note-on events for.  This ensures even during retriggering
    // we preserve the fix for #26 (to ensure multiple note-hold output events simulate
    // being pressed together).
    while (stack_peek(0) != 0x42420000) (
        stack_pop(i);
        note = (i & 0xff000000) >> 24;
        velocity = (i & 0xff0000) >> 16;
        dstchannels = i & 0xffff;
        mpos = midisend_multidst(mpos, dstchannels, MIDI_EVENT_NOTE_ON, note, velocity);
        mpos += 1;
    );
    // Pop sentinel
    stack_pop();
    mpos;
);

function send_deferred_note_off(mpos, channel, group)
(
    _send_held_keyswitch_note(mpos, channel, group, 0);
);


// Here we retrigger any keyswitch notes that had been held, because depending on Reaper's
// configuration, it will either generate note-offs to the downstream FX for any unterminated
// note-on that was sent by Reaticulate (if the "Don't send note-offs or pitch reset messages on
// stop/reset" option is not enabled as is the default case), or if Reaper sends CC123 All Notes Off
// during transport start.  Both of these can cause the downstream FX to unpress the keyswitch note
// causing Reaticulate to become out of sync with it.
//
// Fixes #31.
function retrigger_held_keyswitch_notes(mpos, channel)
local (group)
(
    group = 0; loop(MAX_GROUPS,
        mpos = _send_held_keyswitch_note(mpos, channel, group, 1);
        group += 1;
    );
    mpos;
);


function chase_ccs(mpos, articulation, src, dst)
local(ccs, i, bank, offset, bitmap)
(
    ccs = last_ccs_by_channel + (src * 16);
    bank = get_articulation_bank(articulation);
    i = 0; loop(128,
        offset = floor(i / 24);
        bitmap = 1 << (i - (offset * 24));
        (bank[1 + offset] & bitmap) ? (
            (ccs[i] != -1) ? (
                midisend(mpos, MIDI_EVENT_CC + dst, i, ccs[i]);
                mpos += 1;
            );
        );
        i += 1;
    );
    mpos;
);

// Sends a MIDI event to the feedback controller if feedback is enabled.
function feedback_controller_midisend(mpos, msg1, msg2, msg3)
(
    // Only send the event if feedback is enabled
    (midi_feedback & 0x10) ? (
        midi_bus = midi_feedback & 0x0f;
        midisend(mpos, msg1, msg2, msg3);
        midi_bus = 0;
    );
    mpos + 1;
);


// Notifies the feedback controller of a new articulation if feedback is enabled.
//
// This first sends a bank select (CC0+32) indicating the MSB+LSB of the reabank the
// articulation belongs to, then it signals the group for the articulation by a
// magic event (note-off for note 0 where the velocity indicates the group).  Finally
// the actual program change is sent.
//
// All these events occur on the source channel where the articulation change occurred.
function feedback_controller_articulation(mpos, channel, articulation, group)
local(bank, msb, lsb, program)
(
    program = get_articulation_program(articulation);
    (midi_feedback & 0x10 && program != -1) ? (
        bank = get_articulation_bank(articulation);
        msb = get_bank_msb(bank);
        lsb = get_bank_lsb(bank);

        midi_bus = midi_feedback & 0x0f;
        midisend(mpos, MIDI_EVENT_CC + channel, 0, msb);
        midisend(mpos + 1, MIDI_EVENT_CC + channel, 32, lsb);
        midisend(mpos + 2, MIDI_EVENT_NOTE_OFF + channel, 0, group);
        midisend(mpos + 3, MIDI_EVENT_PROGRAM + channel, program, 0);
        midi_bus = 0;

        mpos + 4;
    ) : (
        mpos;
    );
);


function _enqueue_articulation(program, channel, except_program)
(
    // Do not enqueue articulation if it was already triggered since
    // activate() was called.  Fixes #44.
    (program != except_program && program != -1 &&
     activated_programs[program / 32] & (1 << (program % 32)) == 0) ? (
        stack_push(program | (channel << 8));
    );
);


function emit_output_event(mpos, channel, program, group, articulation, event, last_dstchannels)
local(flags, output_type, dstchannel, dstchannels, param1, param2, should_route, use_current_routing, ch)
(
    flags = get_articulation_flags(articulation);
    output_type = get_output_event_type(event);
    dstchannel = get_output_event_dstchannel(event);
    param1 = get_output_event_param1(event);
    param2 = get_output_event_param2(event);
    should_route = get_output_event_should_route(event);
    use_current_routing = get_output_event_use_current_routing(event);

    (use_current_routing) ? (
        // Output event wants to use existing routing that was set up by a prior
        // articulation.
        dstchannels = last_dstchannels;
    ) : (
        dstchannels = 1 << dstchannel;
    );

    (output_type == OUTPUT_TYPE_PROGRAM) ? (
        mpos = midisend_multidst(mpos, dstchannels, MIDI_EVENT_PROGRAM, param1, 0);
    );
    (output_type == OUTPUT_TYPE_NOTE) ? (
        mpos = midisend_multidst(mpos, dstchannels, MIDI_EVENT_NOTE_ON, param1, param2 ? param2 : 127);
        // Here we send the note-offs with a large enough offset to ensure they follow all
        // note-ons from the list of output events for this articulation.  This causes
        // multiple note output events to simulate pressing the keys simultaneously.
        //
        // Fixes #20.
        mpos = midisend_multidst(mpos + 50, dstchannels, MIDI_EVENT_NOTE_OFF, param1, 0);
    );
    (output_type == OUTPUT_TYPE_NOTE_HOLD) ? (
        off_program = get_articulation_off_program(articulation);
        (program != off_program || off_program > 127) ? (
            // Ensure note-on velocity is 127 if not otherwise defined.
            param2 = param2 ? param2 : 127;
            add_held_keyswitch(channel, group, param1, param2, dstchannel);
            mpos = midisend_multidst(mpos, dstchannels, MIDI_EVENT_NOTE_ON, param1, param2);
        ) : (
            add_held_keyswitch(channel, group, 0, 0, 0);
        );
    );
    (output_type == OUTPUT_TYPE_CC) ? (
        mpos = midisend_multidst(mpos, dstchannels, MIDI_EVENT_CC, param1, param2);
        // FIXME: send for midi feedback
    );
    (output_type == OUTPUT_TYPE_ARTICULATION) ? (
        // Here we have a referenced articulation we need to follow.  Push the articulation
        // details onto the stack so that activate() below can continue processing them.
        //
        // Enqueue articulation to all dstchannels
        ch = 0; loop(16,
            ((dstchannels & (1 << ch)) != 0) ? (
                // TODO: should we propagate should_route to the new articulation?
                _enqueue_articulation(param1, ch, program);
            );
            ch += 1;
        );
    );

    (should_route) ? (
        (last_dstchannels & (1 << dstchannel) == 0 && flags & ARTICULATION_FLAG_CHASE) ? (
            // New dst channel was not already in previous destination channel list, so
            // need to chase CCs to the new dst channel.
            mpos = chase_ccs(mpos, articulation, channel, dstchannel);
        );
        // Include dstchannels for output event in the dstchannels bitmap.
        channel_map[channel] |= dstchannels;
    );
    mpos;
);


function update_channel_articulation_flags(channel)
local(group, articulation, flags)
(
    flags = 0;
    group = 0; loop(MAX_GROUPS,
        articulation = get_active_articulation(channel, group);
        articulation ? (
            flags |= get_articulation_flags(articulation);
        );
        group += 1;
    );
    all_articulation_flags_by_channel[channel] = flags;
);


function _activate(mpos, channel, program, articulation, do_update)
local(articulation, num_outputs, group, control, current_program, flags,
      last_dstchannels, i, output_type, should_route)
(
    // Keep track that this program was already activated.  This helps us avoid
    // infinite recursion that can be caused by the use of art output events.
    // See also _enqueue_articulation() where this bitmap is checked.
    activated_programs[program / 32] |= 1 << (program % 32);
    group = get_articulation_group(articulation);
    flags = get_articulation_flags(articulation);
    version = get_articulation_version(articulation);
    last_program = get_active_program(channel, group);
    (last_program != program || group == 3 || flags & ARTICULATION_FLAG_TOGGLE) ? (
        do_update ? (
            update_current_channel_program(channel, program, group, flags);
        );
    );

    num_outputs = get_articulation_num_outputs(articulation);
    (num_outputs > 0) ? (
        // Before we start processing output events, send deferred notes off for this group.
        // By doing this here, instead of in emit_output_event(), we ensure that multiple
        // note-hold output events are processed without any intervening note-offs.
        //
        // This, combined with supporting multiple held notes per group, fixes #20.
        mpos = send_deferred_note_off(mpos, channel, group);
        // This program has output events.  Before processing them, clear the channel
        // routing map.
        last_dstchannels = channel_map[channel];
        channel_map[channel] = 0;
        // Track whether we had any output events that setup routing.
        should_route = 0;
        i = 0; loop(num_outputs,
            event = get_articulation_output_event(articulation, i);
            filter_program = version > 0 ? get_output_event_filter_program(event) : -1;
            (filter_program < 0 || is_program_active(channel, filter_program)) ? (
                output_type = get_output_event_type(event);
                should_route |= get_output_event_should_route(event);
                mpos = emit_output_event(mpos, channel, program, group, articulation, event, last_dstchannels);
            );
            i += 1;
        );
        // If all output events were set to not setup routing, then here we restore the
        // channel map we had before.
        (channel_map[channel] == 0 && !should_route) ? (
            channel_map[channel] = last_dstchannels;
        );
    ) : (
        // There are no output events defined for this program.  We're not going to
        // clear the current channel routing map but we will release any held
        // notes for this channel and group.
        mpos = send_deferred_note_off(mpos, channel, group);
    );
    update_channel_articulation_flags(channel);
    mpos = feedback_controller_articulation(mpos, channel, articulation, group);

    // If the activated program acts as a filter for some other articulation's
    // output events, retrigger all active articulations if they are different
    // than this program that was just activated.
    (flags & ARTICULATION_FLAG_IS_FILTER) ? (
        _enqueue_articulation(get_active_program(channel, 0), channel, program);
        _enqueue_articulation(get_active_program(channel, 1), channel, program);
        _enqueue_articulation(get_active_program(channel, 2), channel, program);
        _enqueue_articulation(get_active_program(channel, 3), channel, program);
    );
    mpos;
);

function activate(mpos, channel, program)
local (group, cascade_channel, cascade_program, cascade_articulation, cascade_group)
(
    // This array keeps track of activated programs to avoid loops via art
    // output events.
    memset(activated_programs, 0, 4);
    articulation = get_articulation(channel, program);
    articulation ? (
        mpos = _activate(mpos, channel, program, articulation, 1);
        // If the articulation had an OUTPUT_TYPE_ARTICULATION output event, then _activate()
        // will have pushed the articulation details onto the stack, which we can now
        // follow.
        //
        // This allows a form of indirection between articulations.  Fixes #18.
        stack_peek(0) ? (
            group = get_articulation_group(articulation);
            while (stack_peek(0)) (
                stack_pop(artinfo);
                cascade_channel = (artinfo & 0xff00) >> 8;
                cascade_program = artinfo & 0xff;
                cascade_articulation = get_articulation(cascade_channel, cascade_program);
                (cascade_articulation) ? (
                    cascade_group = get_articulation_group(cascade_articulation);
                    // Trigger the referenced articulation but don't actually cause the UI
                    // to update unless the group is different than the initial entry
                    // articulation's group.
                    mpos = _activate(mpos, cascade_channel, cascade_program,
                                     cascade_articulation, cascade_group != group);
                );
            );
        );
    );
    mpos;
);


function get_articulation_by_output_event(type, channel, msg2, msg3)
local(idx, value)
(
    idx = -1;
    (type == MIDI_EVENT_NOTE_ON || type == MIDI_EVENT_NOTE_OFF) ? (
        idx = 128 + msg2;
    ) : (
        (type == MIDI_EVENT_CC) ? (
            idx = 256 + (msg2 * 128) + msg3;
        ) : (
            (type == MIDI_EVENT_PROGRAM) ? (
                idx = msg2;
            );
        );
    );
    (idx != -1) ? (
        idx += (256 + 128 * 128) * channel;
        value = articulations_by_output_event[idx];
        this.articulation = value & 0x00ffffff;
        this.articulation ? (
            this.event = get_articulation_output_event(this.articulation, value >> 24);
        );
    ) : (
        this.articulation = 0;
        this.event = 0;
    );
);

function update_current_channel_program_by_output_event(type, channel, msg2, msg3)
local(match, output_type, group, flags)
(
    match.get_articulation_by_output_event(type, channel, msg2, msg3);
    output_type = get_output_event_type(match.event);
    (match.articulation) ? (
        program = get_articulation_program(match.articulation);
        group = get_articulation_group(match.articulation);
        flags = get_articulation_flags(match.articulation);
        update_current_channel_program(channel, program, group, flags);
        1;
    ) : (
        0;
    );
);


// Process articulations triggered via OPCODE_ACTIVATE_ARTICULATION
(have_pending_activations) ? (
    have_pending_activations = 0;
    channel = 0; loop(16,
        program = pending_activations[channel];
        (program & 0x0100) ? (
            program = program & 0xff;
            // Set byte 1 to 0x02 to indicate the requested program change is processed.
            pending_activations[channel] = program | 0x0200;
            activate(0, channel, program);
        );
        channel += 1;
    );
);


memset(program_change_mpos_delta, 0, 16);

while (midirecv(mpos, msg1, msg2, msg3)) (
    type = msg1 & 0xf0;
    channel = msg1 & 0x0f;
    mpos += program_change_mpos_delta[channel];
    (type == MIDI_EVENT_PROGRAM) ? (
        // Trigger the articulation only if it wasn't previously just activated via
        // opcode.
        (pending_activations[channel] == 0 || pending_activations[channel] & 0xff != msg2) ? (
            newmpos = activate(mpos, channel, msg2);
            program_change_mpos_delta[channel] = newmpos - mpos;
        );
        // Now clear the pending activation as we just filtered out the duplicate.
        pending_activations[channel] = 0;
    ) : (
        // This wasn't a program change, but we do have a bit of work ahead of us:
        // tracking active notes, current CC values, chasing and antihanging,
        // and detecting if a manual keyswitch was triggered based on output
        // events.
        dstchannels = channel_map[channel];

        // First note on/off handling.
        (type == MIDI_EVENT_NOTE_ON && msg3 > 0) ? (
            // Is the new note a keyswitch for an articulation?  If so, update
            // the current program for the channel.
            !update_current_channel_program_by_output_event(type, channel, msg2, msg3) ? (
                // Wasn't a keyswitch, so track the note-on event and update the GUI.
                noteinfo = active_dstchannels_by_note + channel * 16 * 2 + msg2 * 2;
                noteinfo[0] |= dstchannels;
                update_active_notes_for_gui(channel, msg2, 1);
            );
        ) : (
            // It's not a note-on, check to see if it's a note-off.
            (type == MIDI_EVENT_NOTE_OFF || (type == MIDI_EVENT_NOTE_ON && msg3 == 0)) ? (
                // Send note off to previous channel the note-on had been routed to (if applicable)
                noteinfo = active_dstchannels_by_note + channel * 16 * 2 + msg2 * 2;
                last_flags = all_articulation_flags_by_channel[channel];
                (last_flags & ARTICULATION_FLAG_ANTIHANG) ? (
                    // Send the note-off to all dstchannels the note-on was sent
                    // to except for the current dstchannels since we're going to
                    // do that below.
                    last_dstchannels = noteinfo[0] & ($~16 ~ dstchannels);
                    mpos = midisend_multidst(mpos, last_dstchannels, type, msg2, msg3);
                );
                // Now that we've sent the note-off event to all the channels that had
                // seen the note-on (those not in the current dstchannels list anyway),
                // we can reset it.
                noteinfo[0] = 0;
                update_active_notes_for_gui(channel, msg2, 0);

                // For articulations doing note-hold outputs, if the note that was released
                // is the current program for the channel, since it's now being
                // released, if the active articulation has a release program defined,
                // set it to that.
                match.get_articulation_by_output_event(type, channel, msg2, msg3);
                (match.articulation && get_output_event_type(match.event) == OUTPUT_TYPE_NOTE_HOLD) ? (
                    // The note being released maps to an output event of some articulation on this
                    // channel. Check now to see if that articulation is currently active for the
                    // same group.
                    group = get_articulation_group(match.articulation);
                    active_articulation = get_active_articulation(channel, group);
                    release_program = get_articulation_off_program(match.articulation);
                    (active_articulation == match.articulation && release_program < 128) ? (
                        // The note-off does indeed correspond to an active articulation with a
                        // release program defined.  Now activate that release program.
                        flags = get_articulation_flags(match.articulation);
                        update_current_channel_program(channel, release_program, group, flags);
                    );
                );
            );
        );

        // Now special CC handling, for blocking bank selects, antihanging for sustain and
        // breath CCs, and tracking CCs for later chasing.
        (type == MIDI_EVENT_CC) ? (
            (msg2 == 0 || msg2 == 32) ? (
                // Do we need to block the bank select?
                flags = all_articulation_flags_by_channel[channel];
                (flags & ARTICULATION_FLAG_BLOCK_BANK_CHANGE == 0) ? (
                    // No, send it along.
                    update_current_channel_program_by_output_event(type, channel, msg2, msg3);
                    mpos = midisend_multidst(mpos, dstchannels, type, msg2, msg3);
                );
            ) : (
                (msg2 == 123) ? (
                    // All notes off for destination MIDI channels.  Tell GUI
                    // that notes turned off for source channel.
                    update_active_notes_for_gui(channel, -1, 0);
                    // Now loop over dstchannels and clear the active notes
                    // we're tracking.
                    i = 0; loop(16,
                        (dstchannels & (1 << i)) ? (
                            active_dstchannels_by_note[i * 16 * 2 + msg2 * 2] = 0;
                        );
                    );
                ) : (
                    // Remember this CC value for chasing.
                    update_current_ccs_for_gui(channel, msg2, msg3);

                    // Handle anti CC hanging
                    (msg2 == 2 || msg2 == 64 || msg2 == 66) ? (
                        idx = channel * 16 + msg2;
                        bitmap = active_channels_by_cc[idx];
                        (msg3 > 0) ? (
                            // Are there current dstchannels that aren't already included
                            // in the CC's dstchannels?
                            (dstchannels & ($~16 ~ bitmap)) ? (
                                // Yes, so add them if the articulation has the antihangcc flag.
                                flags = all_articulation_flags_by_channel[channel];
                                (flags & ARTICULATION_FLAG_ANTIHANG_CC) ? (
                                    // Yes, articulation has the CC antihang flag.
                                    active_channels_by_cc[idx] |= dstchannels;
                                );
                            );
                        ) : (
                            // Replay this 0-value CC on all previous dst channels for this CC except
                            // on the current dstchannel since that's aleady about to happen.
                            bitmap &= $~16 ~ dstchannels;
                            mpos = midisend_multidst(mpos, bitmap, type, msg2, 0);
                            active_channels_by_cc[idx] = 0;
                        );
                    );
                );
                // Detect manual articulation changes via CC (if applicable), and finally route the
                // event to the current destination channels.
                update_current_channel_program_by_output_event(type, channel, msg2, msg3);
                mpos = midisend_multidst(mpos, dstchannels, type, msg2, msg3);
                // This might be a bit too aggressive.  If Reaper generates CC123 on transport
                // play, then we will already retrigger held notes below.  Doing it again
                // here may be unnecessary.  So disable for now.
                // (msg2 == 123) ? (
                //     retrigger_held_keyswitch_notes(mpos, channel);
                // );

                (type == MIDI_EVENT_CC) ? (
                    mpos = feedback_controller_midisend(mpos, msg1, msg2, msg3);
                );
            );
        ) : (
            // Non-CC MIDI event (including notes).  Route away.
            mpos = midisend_multidst(mpos, dstchannels, type, msg2, msg3);
        );
    );
);

(play_state != last_play_state) ? (
    last_play_state = play_state;
    (play_state == 1) ? (
        // Transport started playing.  Anticipate either forged note-offs or CC123 All Notes Off
        // coming from Reaper.
        //
        // Empircally, CC123 comes after the forged note-offs.  If it comes in the next block then
        // we'll miss it (in which case see above comment about CC123), but in testing it seems to
        // come in the same block as the explicit note-offs.  This is why we set the mpos a fair bit
        // ahead in the block, to ensure they come after the CC123.
        mpos += 100;
        channel = 0; loop(16,
            mpos = retrigger_held_keyswitch_notes(mpos, channel);
            channel += 1;
        );
    );
);


(midi_feedback_sync_pending != 0) ? (
    mpos = 0;

    channel = 0; loop(16,
        (midi_feedback_sync_pending & 2) ? (
            // Send current program # for each group.  Incrementing mpos ensures proper
            // ordering.
            group = MAX_GROUPS - 1; loop(MAX_GROUPS,
                articulation = get_active_articulation(channel, group);
                (articulation) ? (
                    mpos = feedback_controller_articulation(mpos, channel, articulation, group);
                );
                group -= 1;
            );
        );

        (midi_feedback_sync_pending & 1) ? (
            // Now send all observed CC values for this channel.
            midi_bus = midi_feedback & 0x0f;
            ccs = last_ccs_by_channel + (channel * 16);
            i = 0; loop(128,
                ccs[i] >= 0 ? (
                    midisend(mpos, MIDI_EVENT_CC + channel, i, ccs[i]);
                    mpos += 1;
                );
                i += 1;
            );
            midi_bus = 0;
        );
        channel += 1;
    );
    midi_feedback_sync_pending = 0;
);

(queue_increment_serial != 0) ? (
    increment_serial();
    queue_increment_serial = 0;
);